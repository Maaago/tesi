\chapter{Codice C++}
	\label{code:cpp}
	Il codice C++ si compone di 3 file \texttt{.cpp} con i 3 relativi header \texttt{.h}:
	
	\noindent\hspace{5px}\begin{tabularx}{\textwidth}{r X}
		\makecell{\textbf{PluginEditor.h}\\\textbf{PluginEditor.cpp}}			&che implementano tutti i metodi relativi all'interfaccia grafica del plugin\\
		\makecell{\textbf{PluginProcessor.h}\\\textbf{PluginProcessor.cpp}}	&che implementano tutti i metodi legati alla tecnologia VST, in particolare qui verrà richiamata la funzione che processerà i singoli sample\\
		\makecell{\textbf{Clipper.h}\\\textbf{Clipper.cpp}}					&dove è implementa tutta la logica di funzionamento del clipper, compreso il metodo numerico a punto fisso geometrico
	\end{tabularx}\\
	
	%\cppcode{PluginEditor.h}
	%\cppcode{PluginEditor.cpp}
	%\cppcode{PluginProcessor.h}
	%\cppcode{PluginProcessor.cpp}
	Nel seguente listato, che rappresenta parte del file \texttt{PluginProcessor.cpp}, parte del codice è stato omesso a causa della sua eccessiva lunghezza. Sono state incluse solo le funzioni strettamente necessarie alla comprensione del funzionamento dell'intero progetto.
	\begin{lstlisting}[caption={PluginProcessor.cpp},label=code:PluginProcessor.cpp,style=code,style=cpp,language=cppl,gobble=8]
		ClipperAudioProcessor::ClipperAudioProcessor()
		#ifndef JucePlugin_PreferredChannelConfigurations
		     : AudioProcessor (BusesProperties()
		                     #if ! JucePlugin_IsMidiEffect
		                      #if ! JucePlugin_IsSynth
		                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
		                      #endif
		                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
		                     #endif
		                       )
		#endif
		{
			auto totalNumInputChannels  = getTotalNumInputChannels();
			for(int channel=0;channel<totalNumInputChannels;channel++)
				clippers.push_back(Clipper(44100));
		}

		ClipperAudioProcessor::~ClipperAudioProcessor() {}
		
		.
		.
		.
		
		void ClipperAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
		{
			juce::ScopedNoDenormals noDenormals;
			auto totalNumInputChannels  = getTotalNumInputChannels();
			auto totalNumOutputChannels = getTotalNumOutputChannels();

			for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
				buffer.clear (i, 0, buffer.getNumSamples());

			//std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();
			if(!bypass)
			{
				for(int channel=0;channel<totalNumInputChannels;channel++)
				{
					auto *channelData = buffer.getWritePointer(channel);
					
					clippers[channel].process(channelData, buffer.getNumSamples());
				}
			}
			
			//std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();
			//log << std::chrono::duration_cast<std::chrono::microseconds>(end-start).count() << std::endl;
		}
		
		.
		.
		.
	\end{lstlisting}
	\vspace{10px}
	
	\cppcode{Clipper.h}
	\cppcode{Clipper.cpp}